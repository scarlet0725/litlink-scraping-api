// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/scarlet0725/prism-api/ent/artist"
	"github.com/scarlet0725/prism-api/ent/event"
	"github.com/scarlet0725/prism-api/ent/externalcalendar"
	"github.com/scarlet0725/prism-api/ent/googleoauthtoken"
	"github.com/scarlet0725/prism-api/ent/predicate"
	"github.com/scarlet0725/prism-api/ent/role"
	"github.com/scarlet0725/prism-api/ent/user"
	"github.com/scarlet0725/prism-api/ent/venue"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArtist           = "Artist"
	TypeEvent            = "Event"
	TypeExternalCalendar = "ExternalCalendar"
	TypeGoogleOauthToken = "GoogleOauthToken"
	TypeRole             = "Role"
	TypeUser             = "User"
	TypeVenue            = "Venue"
)

// ArtistMutation represents an operation that mutates the Artist nodes in the graph.
type ArtistMutation struct {
	config
	op            Op
	typ           string
	id            *int
	artist_id     *string
	name          *string
	url           *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	events        map[int]struct{}
	removedevents map[int]struct{}
	clearedevents bool
	done          bool
	oldValue      func(context.Context) (*Artist, error)
	predicates    []predicate.Artist
}

var _ ent.Mutation = (*ArtistMutation)(nil)

// artistOption allows management of the mutation configuration using functional options.
type artistOption func(*ArtistMutation)

// newArtistMutation creates new mutation for the Artist entity.
func newArtistMutation(c config, op Op, opts ...artistOption) *ArtistMutation {
	m := &ArtistMutation{
		config:        c,
		op:            op,
		typ:           TypeArtist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtistID sets the ID field of the mutation.
func withArtistID(id int) artistOption {
	return func(m *ArtistMutation) {
		var (
			err   error
			once  sync.Once
			value *Artist
		)
		m.oldValue = func(ctx context.Context) (*Artist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtist sets the old Artist of the mutation.
func withArtist(node *Artist) artistOption {
	return func(m *ArtistMutation) {
		m.oldValue = func(context.Context) (*Artist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtistMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArtistID sets the "artist_id" field.
func (m *ArtistMutation) SetArtistID(s string) {
	m.artist_id = &s
}

// ArtistID returns the value of the "artist_id" field in the mutation.
func (m *ArtistMutation) ArtistID() (r string, exists bool) {
	v := m.artist_id
	if v == nil {
		return
	}
	return *v, true
}

// OldArtistID returns the old "artist_id" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldArtistID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtistID: %w", err)
	}
	return oldValue.ArtistID, nil
}

// ResetArtistID resets all changes to the "artist_id" field.
func (m *ArtistMutation) ResetArtistID() {
	m.artist_id = nil
}

// SetName sets the "name" field.
func (m *ArtistMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ArtistMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ArtistMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *ArtistMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ArtistMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ArtistMutation) ClearURL() {
	m.url = nil
	m.clearedFields[artist.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ArtistMutation) URLCleared() bool {
	_, ok := m.clearedFields[artist.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ArtistMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, artist.FieldURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtistMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtistMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtistMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtistMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtistMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtistMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ArtistMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ArtistMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ArtistMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[artist.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ArtistMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[artist.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ArtistMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, artist.FieldDeletedAt)
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *ArtistMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *ArtistMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *ArtistMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *ArtistMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *ArtistMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *ArtistMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *ArtistMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the ArtistMutation builder.
func (m *ArtistMutation) Where(ps ...predicate.Artist) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtistMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtistMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Artist, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtistMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtistMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Artist).
func (m *ArtistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtistMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.artist_id != nil {
		fields = append(fields, artist.FieldArtistID)
	}
	if m.name != nil {
		fields = append(fields, artist.FieldName)
	}
	if m.url != nil {
		fields = append(fields, artist.FieldURL)
	}
	if m.created_at != nil {
		fields = append(fields, artist.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, artist.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, artist.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artist.FieldArtistID:
		return m.ArtistID()
	case artist.FieldName:
		return m.Name()
	case artist.FieldURL:
		return m.URL()
	case artist.FieldCreatedAt:
		return m.CreatedAt()
	case artist.FieldUpdatedAt:
		return m.UpdatedAt()
	case artist.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artist.FieldArtistID:
		return m.OldArtistID(ctx)
	case artist.FieldName:
		return m.OldName(ctx)
	case artist.FieldURL:
		return m.OldURL(ctx)
	case artist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case artist.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case artist.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Artist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artist.FieldArtistID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtistID(v)
		return nil
	case artist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case artist.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case artist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case artist.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case artist.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Artist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtistMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(artist.FieldURL) {
		fields = append(fields, artist.FieldURL)
	}
	if m.FieldCleared(artist.FieldDeletedAt) {
		fields = append(fields, artist.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtistMutation) ClearField(name string) error {
	switch name {
	case artist.FieldURL:
		m.ClearURL()
		return nil
	case artist.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Artist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtistMutation) ResetField(name string) error {
	switch name {
	case artist.FieldArtistID:
		m.ResetArtistID()
		return nil
	case artist.FieldName:
		m.ResetName()
		return nil
	case artist.FieldURL:
		m.ResetURL()
		return nil
	case artist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case artist.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case artist.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Artist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtistMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, artist.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artist.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, artist.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artist.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, artist.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtistMutation) EdgeCleared(name string) bool {
	switch name {
	case artist.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtistMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Artist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtistMutation) ResetEdge(name string) error {
	switch name {
	case artist.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Artist edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op             Op
	typ            string
	id             *int
	event_id       *string
	name           *string
	date           *time.Time
	open_time      *time.Time
	start_time     *time.Time
	end_time       *time.Time
	description    *string
	url            *string
	ticket_url     *string
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	clearedFields  map[string]struct{}
	users          map[int]struct{}
	removedusers   map[int]struct{}
	clearedusers   bool
	artists        map[int]struct{}
	removedartists map[int]struct{}
	clearedartists bool
	venue          *int
	clearedvenue   bool
	done           bool
	oldValue       func(context.Context) (*Event, error)
	predicates     []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventID sets the "event_id" field.
func (m *EventMutation) SetEventID(s string) {
	m.event_id = &s
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *EventMutation) EventID() (r string, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *EventMutation) ResetEventID() {
	m.event_id = nil
}

// SetName sets the "name" field.
func (m *EventMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EventMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EventMutation) ResetName() {
	m.name = nil
}

// SetDate sets the "date" field.
func (m *EventMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *EventMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "date" field.
func (m *EventMutation) ClearDate() {
	m.date = nil
	m.clearedFields[event.FieldDate] = struct{}{}
}

// DateCleared returns if the "date" field was cleared in this mutation.
func (m *EventMutation) DateCleared() bool {
	_, ok := m.clearedFields[event.FieldDate]
	return ok
}

// ResetDate resets all changes to the "date" field.
func (m *EventMutation) ResetDate() {
	m.date = nil
	delete(m.clearedFields, event.FieldDate)
}

// SetOpenTime sets the "open_time" field.
func (m *EventMutation) SetOpenTime(t time.Time) {
	m.open_time = &t
}

// OpenTime returns the value of the "open_time" field in the mutation.
func (m *EventMutation) OpenTime() (r time.Time, exists bool) {
	v := m.open_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenTime returns the old "open_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldOpenTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenTime: %w", err)
	}
	return oldValue.OpenTime, nil
}

// ClearOpenTime clears the value of the "open_time" field.
func (m *EventMutation) ClearOpenTime() {
	m.open_time = nil
	m.clearedFields[event.FieldOpenTime] = struct{}{}
}

// OpenTimeCleared returns if the "open_time" field was cleared in this mutation.
func (m *EventMutation) OpenTimeCleared() bool {
	_, ok := m.clearedFields[event.FieldOpenTime]
	return ok
}

// ResetOpenTime resets all changes to the "open_time" field.
func (m *EventMutation) ResetOpenTime() {
	m.open_time = nil
	delete(m.clearedFields, event.FieldOpenTime)
}

// SetStartTime sets the "start_time" field.
func (m *EventMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *EventMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStartTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *EventMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[event.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *EventMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[event.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *EventMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, event.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *EventMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *EventMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEndTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *EventMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[event.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *EventMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[event.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *EventMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, event.FieldEndTime)
}

// SetDescription sets the "description" field.
func (m *EventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[event.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[event.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, event.FieldDescription)
}

// SetURL sets the "url" field.
func (m *EventMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *EventMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *EventMutation) ClearURL() {
	m.url = nil
	m.clearedFields[event.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *EventMutation) URLCleared() bool {
	_, ok := m.clearedFields[event.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *EventMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, event.FieldURL)
}

// SetTicketURL sets the "ticket_url" field.
func (m *EventMutation) SetTicketURL(s string) {
	m.ticket_url = &s
}

// TicketURL returns the value of the "ticket_url" field in the mutation.
func (m *EventMutation) TicketURL() (r string, exists bool) {
	v := m.ticket_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketURL returns the old "ticket_url" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTicketURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketURL: %w", err)
	}
	return oldValue.TicketURL, nil
}

// ClearTicketURL clears the value of the "ticket_url" field.
func (m *EventMutation) ClearTicketURL() {
	m.ticket_url = nil
	m.clearedFields[event.FieldTicketURL] = struct{}{}
}

// TicketURLCleared returns if the "ticket_url" field was cleared in this mutation.
func (m *EventMutation) TicketURLCleared() bool {
	_, ok := m.clearedFields[event.FieldTicketURL]
	return ok
}

// ResetTicketURL resets all changes to the "ticket_url" field.
func (m *EventMutation) ResetTicketURL() {
	m.ticket_url = nil
	delete(m.clearedFields, event.FieldTicketURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[event.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[event.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, event.FieldDeletedAt)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *EventMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *EventMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *EventMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *EventMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *EventMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *EventMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *EventMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddArtistIDs adds the "artists" edge to the Artist entity by ids.
func (m *EventMutation) AddArtistIDs(ids ...int) {
	if m.artists == nil {
		m.artists = make(map[int]struct{})
	}
	for i := range ids {
		m.artists[ids[i]] = struct{}{}
	}
}

// ClearArtists clears the "artists" edge to the Artist entity.
func (m *EventMutation) ClearArtists() {
	m.clearedartists = true
}

// ArtistsCleared reports if the "artists" edge to the Artist entity was cleared.
func (m *EventMutation) ArtistsCleared() bool {
	return m.clearedartists
}

// RemoveArtistIDs removes the "artists" edge to the Artist entity by IDs.
func (m *EventMutation) RemoveArtistIDs(ids ...int) {
	if m.removedartists == nil {
		m.removedartists = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artists, ids[i])
		m.removedartists[ids[i]] = struct{}{}
	}
}

// RemovedArtists returns the removed IDs of the "artists" edge to the Artist entity.
func (m *EventMutation) RemovedArtistsIDs() (ids []int) {
	for id := range m.removedartists {
		ids = append(ids, id)
	}
	return
}

// ArtistsIDs returns the "artists" edge IDs in the mutation.
func (m *EventMutation) ArtistsIDs() (ids []int) {
	for id := range m.artists {
		ids = append(ids, id)
	}
	return
}

// ResetArtists resets all changes to the "artists" edge.
func (m *EventMutation) ResetArtists() {
	m.artists = nil
	m.clearedartists = false
	m.removedartists = nil
}

// SetVenueID sets the "venue" edge to the Venue entity by id.
func (m *EventMutation) SetVenueID(id int) {
	m.venue = &id
}

// ClearVenue clears the "venue" edge to the Venue entity.
func (m *EventMutation) ClearVenue() {
	m.clearedvenue = true
}

// VenueCleared reports if the "venue" edge to the Venue entity was cleared.
func (m *EventMutation) VenueCleared() bool {
	return m.clearedvenue
}

// VenueID returns the "venue" edge ID in the mutation.
func (m *EventMutation) VenueID() (id int, exists bool) {
	if m.venue != nil {
		return *m.venue, true
	}
	return
}

// VenueIDs returns the "venue" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VenueID instead. It exists only for internal usage by the builders.
func (m *EventMutation) VenueIDs() (ids []int) {
	if id := m.venue; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVenue resets all changes to the "venue" edge.
func (m *EventMutation) ResetVenue() {
	m.venue = nil
	m.clearedvenue = false
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.event_id != nil {
		fields = append(fields, event.FieldEventID)
	}
	if m.name != nil {
		fields = append(fields, event.FieldName)
	}
	if m.date != nil {
		fields = append(fields, event.FieldDate)
	}
	if m.open_time != nil {
		fields = append(fields, event.FieldOpenTime)
	}
	if m.start_time != nil {
		fields = append(fields, event.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, event.FieldEndTime)
	}
	if m.description != nil {
		fields = append(fields, event.FieldDescription)
	}
	if m.url != nil {
		fields = append(fields, event.FieldURL)
	}
	if m.ticket_url != nil {
		fields = append(fields, event.FieldTicketURL)
	}
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, event.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldEventID:
		return m.EventID()
	case event.FieldName:
		return m.Name()
	case event.FieldDate:
		return m.Date()
	case event.FieldOpenTime:
		return m.OpenTime()
	case event.FieldStartTime:
		return m.StartTime()
	case event.FieldEndTime:
		return m.EndTime()
	case event.FieldDescription:
		return m.Description()
	case event.FieldURL:
		return m.URL()
	case event.FieldTicketURL:
		return m.TicketURL()
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldEventID:
		return m.OldEventID(ctx)
	case event.FieldName:
		return m.OldName(ctx)
	case event.FieldDate:
		return m.OldDate(ctx)
	case event.FieldOpenTime:
		return m.OldOpenTime(ctx)
	case event.FieldStartTime:
		return m.OldStartTime(ctx)
	case event.FieldEndTime:
		return m.OldEndTime(ctx)
	case event.FieldDescription:
		return m.OldDescription(ctx)
	case event.FieldURL:
		return m.OldURL(ctx)
	case event.FieldTicketURL:
		return m.OldTicketURL(ctx)
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case event.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case event.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case event.FieldOpenTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenTime(v)
		return nil
	case event.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case event.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case event.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case event.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case event.FieldTicketURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketURL(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldDate) {
		fields = append(fields, event.FieldDate)
	}
	if m.FieldCleared(event.FieldOpenTime) {
		fields = append(fields, event.FieldOpenTime)
	}
	if m.FieldCleared(event.FieldStartTime) {
		fields = append(fields, event.FieldStartTime)
	}
	if m.FieldCleared(event.FieldEndTime) {
		fields = append(fields, event.FieldEndTime)
	}
	if m.FieldCleared(event.FieldDescription) {
		fields = append(fields, event.FieldDescription)
	}
	if m.FieldCleared(event.FieldURL) {
		fields = append(fields, event.FieldURL)
	}
	if m.FieldCleared(event.FieldTicketURL) {
		fields = append(fields, event.FieldTicketURL)
	}
	if m.FieldCleared(event.FieldDeletedAt) {
		fields = append(fields, event.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldDate:
		m.ClearDate()
		return nil
	case event.FieldOpenTime:
		m.ClearOpenTime()
		return nil
	case event.FieldStartTime:
		m.ClearStartTime()
		return nil
	case event.FieldEndTime:
		m.ClearEndTime()
		return nil
	case event.FieldDescription:
		m.ClearDescription()
		return nil
	case event.FieldURL:
		m.ClearURL()
		return nil
	case event.FieldTicketURL:
		m.ClearTicketURL()
		return nil
	case event.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldEventID:
		m.ResetEventID()
		return nil
	case event.FieldName:
		m.ResetName()
		return nil
	case event.FieldDate:
		m.ResetDate()
		return nil
	case event.FieldOpenTime:
		m.ResetOpenTime()
		return nil
	case event.FieldStartTime:
		m.ResetStartTime()
		return nil
	case event.FieldEndTime:
		m.ResetEndTime()
		return nil
	case event.FieldDescription:
		m.ResetDescription()
		return nil
	case event.FieldURL:
		m.ResetURL()
		return nil
	case event.FieldTicketURL:
		m.ResetTicketURL()
		return nil
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.users != nil {
		edges = append(edges, event.EdgeUsers)
	}
	if m.artists != nil {
		edges = append(edges, event.EdgeArtists)
	}
	if m.venue != nil {
		edges = append(edges, event.EdgeVenue)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeArtists:
		ids := make([]ent.Value, 0, len(m.artists))
		for id := range m.artists {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeVenue:
		if id := m.venue; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedusers != nil {
		edges = append(edges, event.EdgeUsers)
	}
	if m.removedartists != nil {
		edges = append(edges, event.EdgeArtists)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeArtists:
		ids := make([]ent.Value, 0, len(m.removedartists))
		for id := range m.removedartists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedusers {
		edges = append(edges, event.EdgeUsers)
	}
	if m.clearedartists {
		edges = append(edges, event.EdgeArtists)
	}
	if m.clearedvenue {
		edges = append(edges, event.EdgeVenue)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeUsers:
		return m.clearedusers
	case event.EdgeArtists:
		return m.clearedartists
	case event.EdgeVenue:
		return m.clearedvenue
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeVenue:
		m.ClearVenue()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeUsers:
		m.ResetUsers()
		return nil
	case event.EdgeArtists:
		m.ResetArtists()
		return nil
	case event.EdgeVenue:
		m.ResetVenue()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// ExternalCalendarMutation represents an operation that mutates the ExternalCalendar nodes in the graph.
type ExternalCalendarMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	calendar_id   *string
	source_type   *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*ExternalCalendar, error)
	predicates    []predicate.ExternalCalendar
}

var _ ent.Mutation = (*ExternalCalendarMutation)(nil)

// externalcalendarOption allows management of the mutation configuration using functional options.
type externalcalendarOption func(*ExternalCalendarMutation)

// newExternalCalendarMutation creates new mutation for the ExternalCalendar entity.
func newExternalCalendarMutation(c config, op Op, opts ...externalcalendarOption) *ExternalCalendarMutation {
	m := &ExternalCalendarMutation{
		config:        c,
		op:            op,
		typ:           TypeExternalCalendar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExternalCalendarID sets the ID field of the mutation.
func withExternalCalendarID(id int) externalcalendarOption {
	return func(m *ExternalCalendarMutation) {
		var (
			err   error
			once  sync.Once
			value *ExternalCalendar
		)
		m.oldValue = func(ctx context.Context) (*ExternalCalendar, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExternalCalendar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExternalCalendar sets the old ExternalCalendar of the mutation.
func withExternalCalendar(node *ExternalCalendar) externalcalendarOption {
	return func(m *ExternalCalendarMutation) {
		m.oldValue = func(context.Context) (*ExternalCalendar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExternalCalendarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExternalCalendarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExternalCalendarMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExternalCalendarMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExternalCalendar.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ExternalCalendarMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExternalCalendarMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ExternalCalendar entity.
// If the ExternalCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalCalendarMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExternalCalendarMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ExternalCalendarMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ExternalCalendarMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ExternalCalendar entity.
// If the ExternalCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalCalendarMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ExternalCalendarMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[externalcalendar.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ExternalCalendarMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[externalcalendar.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ExternalCalendarMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, externalcalendar.FieldDescription)
}

// SetCalendarID sets the "calendar_id" field.
func (m *ExternalCalendarMutation) SetCalendarID(s string) {
	m.calendar_id = &s
}

// CalendarID returns the value of the "calendar_id" field in the mutation.
func (m *ExternalCalendarMutation) CalendarID() (r string, exists bool) {
	v := m.calendar_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarID returns the old "calendar_id" field's value of the ExternalCalendar entity.
// If the ExternalCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalCalendarMutation) OldCalendarID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalendarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalendarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarID: %w", err)
	}
	return oldValue.CalendarID, nil
}

// ResetCalendarID resets all changes to the "calendar_id" field.
func (m *ExternalCalendarMutation) ResetCalendarID() {
	m.calendar_id = nil
}

// SetSourceType sets the "source_type" field.
func (m *ExternalCalendarMutation) SetSourceType(s string) {
	m.source_type = &s
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *ExternalCalendarMutation) SourceType() (r string, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the ExternalCalendar entity.
// If the ExternalCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalCalendarMutation) OldSourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *ExternalCalendarMutation) ResetSourceType() {
	m.source_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ExternalCalendarMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExternalCalendarMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExternalCalendar entity.
// If the ExternalCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalCalendarMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExternalCalendarMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExternalCalendarMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExternalCalendarMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExternalCalendar entity.
// If the ExternalCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalCalendarMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExternalCalendarMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExternalCalendarMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExternalCalendarMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ExternalCalendar entity.
// If the ExternalCalendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalCalendarMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ExternalCalendarMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[externalcalendar.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ExternalCalendarMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[externalcalendar.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExternalCalendarMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, externalcalendar.FieldDeletedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ExternalCalendarMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ExternalCalendarMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ExternalCalendarMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ExternalCalendarMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ExternalCalendarMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ExternalCalendarMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ExternalCalendarMutation builder.
func (m *ExternalCalendarMutation) Where(ps ...predicate.ExternalCalendar) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExternalCalendarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExternalCalendarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExternalCalendar, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExternalCalendarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExternalCalendarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExternalCalendar).
func (m *ExternalCalendarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExternalCalendarMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, externalcalendar.FieldName)
	}
	if m.description != nil {
		fields = append(fields, externalcalendar.FieldDescription)
	}
	if m.calendar_id != nil {
		fields = append(fields, externalcalendar.FieldCalendarID)
	}
	if m.source_type != nil {
		fields = append(fields, externalcalendar.FieldSourceType)
	}
	if m.created_at != nil {
		fields = append(fields, externalcalendar.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, externalcalendar.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, externalcalendar.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExternalCalendarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case externalcalendar.FieldName:
		return m.Name()
	case externalcalendar.FieldDescription:
		return m.Description()
	case externalcalendar.FieldCalendarID:
		return m.CalendarID()
	case externalcalendar.FieldSourceType:
		return m.SourceType()
	case externalcalendar.FieldCreatedAt:
		return m.CreatedAt()
	case externalcalendar.FieldUpdatedAt:
		return m.UpdatedAt()
	case externalcalendar.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExternalCalendarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case externalcalendar.FieldName:
		return m.OldName(ctx)
	case externalcalendar.FieldDescription:
		return m.OldDescription(ctx)
	case externalcalendar.FieldCalendarID:
		return m.OldCalendarID(ctx)
	case externalcalendar.FieldSourceType:
		return m.OldSourceType(ctx)
	case externalcalendar.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case externalcalendar.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case externalcalendar.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ExternalCalendar field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExternalCalendarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case externalcalendar.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case externalcalendar.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case externalcalendar.FieldCalendarID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarID(v)
		return nil
	case externalcalendar.FieldSourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case externalcalendar.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case externalcalendar.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case externalcalendar.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ExternalCalendar field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExternalCalendarMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExternalCalendarMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExternalCalendarMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ExternalCalendar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExternalCalendarMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(externalcalendar.FieldDescription) {
		fields = append(fields, externalcalendar.FieldDescription)
	}
	if m.FieldCleared(externalcalendar.FieldDeletedAt) {
		fields = append(fields, externalcalendar.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExternalCalendarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExternalCalendarMutation) ClearField(name string) error {
	switch name {
	case externalcalendar.FieldDescription:
		m.ClearDescription()
		return nil
	case externalcalendar.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ExternalCalendar nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExternalCalendarMutation) ResetField(name string) error {
	switch name {
	case externalcalendar.FieldName:
		m.ResetName()
		return nil
	case externalcalendar.FieldDescription:
		m.ResetDescription()
		return nil
	case externalcalendar.FieldCalendarID:
		m.ResetCalendarID()
		return nil
	case externalcalendar.FieldSourceType:
		m.ResetSourceType()
		return nil
	case externalcalendar.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case externalcalendar.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case externalcalendar.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ExternalCalendar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExternalCalendarMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, externalcalendar.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExternalCalendarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case externalcalendar.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExternalCalendarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExternalCalendarMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExternalCalendarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, externalcalendar.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExternalCalendarMutation) EdgeCleared(name string) bool {
	switch name {
	case externalcalendar.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExternalCalendarMutation) ClearEdge(name string) error {
	switch name {
	case externalcalendar.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ExternalCalendar unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExternalCalendarMutation) ResetEdge(name string) error {
	switch name {
	case externalcalendar.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ExternalCalendar edge %s", name)
}

// GoogleOauthTokenMutation represents an operation that mutates the GoogleOauthToken nodes in the graph.
type GoogleOauthTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	refresh_token *string
	access_token  *string
	expiry        *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*GoogleOauthToken, error)
	predicates    []predicate.GoogleOauthToken
}

var _ ent.Mutation = (*GoogleOauthTokenMutation)(nil)

// googleoauthtokenOption allows management of the mutation configuration using functional options.
type googleoauthtokenOption func(*GoogleOauthTokenMutation)

// newGoogleOauthTokenMutation creates new mutation for the GoogleOauthToken entity.
func newGoogleOauthTokenMutation(c config, op Op, opts ...googleoauthtokenOption) *GoogleOauthTokenMutation {
	m := &GoogleOauthTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeGoogleOauthToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoogleOauthTokenID sets the ID field of the mutation.
func withGoogleOauthTokenID(id int) googleoauthtokenOption {
	return func(m *GoogleOauthTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *GoogleOauthToken
		)
		m.oldValue = func(ctx context.Context) (*GoogleOauthToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoogleOauthToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoogleOauthToken sets the old GoogleOauthToken of the mutation.
func withGoogleOauthToken(node *GoogleOauthToken) googleoauthtokenOption {
	return func(m *GoogleOauthTokenMutation) {
		m.oldValue = func(context.Context) (*GoogleOauthToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoogleOauthTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoogleOauthTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoogleOauthTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoogleOauthTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoogleOauthToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRefreshToken sets the "refresh_token" field.
func (m *GoogleOauthTokenMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *GoogleOauthTokenMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the GoogleOauthToken entity.
// If the GoogleOauthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleOauthTokenMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *GoogleOauthTokenMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetAccessToken sets the "access_token" field.
func (m *GoogleOauthTokenMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *GoogleOauthTokenMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the GoogleOauthToken entity.
// If the GoogleOauthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleOauthTokenMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *GoogleOauthTokenMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetExpiry sets the "expiry" field.
func (m *GoogleOauthTokenMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *GoogleOauthTokenMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the GoogleOauthToken entity.
// If the GoogleOauthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleOauthTokenMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *GoogleOauthTokenMutation) ResetExpiry() {
	m.expiry = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *GoogleOauthTokenMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *GoogleOauthTokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *GoogleOauthTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *GoogleOauthTokenMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *GoogleOauthTokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *GoogleOauthTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the GoogleOauthTokenMutation builder.
func (m *GoogleOauthTokenMutation) Where(ps ...predicate.GoogleOauthToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoogleOauthTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoogleOauthTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoogleOauthToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoogleOauthTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoogleOauthTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoogleOauthToken).
func (m *GoogleOauthTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoogleOauthTokenMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.refresh_token != nil {
		fields = append(fields, googleoauthtoken.FieldRefreshToken)
	}
	if m.access_token != nil {
		fields = append(fields, googleoauthtoken.FieldAccessToken)
	}
	if m.expiry != nil {
		fields = append(fields, googleoauthtoken.FieldExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoogleOauthTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case googleoauthtoken.FieldRefreshToken:
		return m.RefreshToken()
	case googleoauthtoken.FieldAccessToken:
		return m.AccessToken()
	case googleoauthtoken.FieldExpiry:
		return m.Expiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoogleOauthTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case googleoauthtoken.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case googleoauthtoken.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case googleoauthtoken.FieldExpiry:
		return m.OldExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown GoogleOauthToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleOauthTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case googleoauthtoken.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case googleoauthtoken.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case googleoauthtoken.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown GoogleOauthToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoogleOauthTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoogleOauthTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleOauthTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GoogleOauthToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoogleOauthTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoogleOauthTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoogleOauthTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GoogleOauthToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoogleOauthTokenMutation) ResetField(name string) error {
	switch name {
	case googleoauthtoken.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case googleoauthtoken.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case googleoauthtoken.FieldExpiry:
		m.ResetExpiry()
		return nil
	}
	return fmt.Errorf("unknown GoogleOauthToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoogleOauthTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, googleoauthtoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoogleOauthTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case googleoauthtoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoogleOauthTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoogleOauthTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoogleOauthTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, googleoauthtoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoogleOauthTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case googleoauthtoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoogleOauthTokenMutation) ClearEdge(name string) error {
	switch name {
	case googleoauthtoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown GoogleOauthToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoogleOauthTokenMutation) ResetEdge(name string) error {
	switch name {
	case googleoauthtoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown GoogleOauthToken edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	role_id       *string
	description   *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Role, error)
	predicates    []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetRoleID sets the "role_id" field.
func (m *RoleMutation) SetRoleID(s string) {
	m.role_id = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *RoleMutation) RoleID() (r string, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *RoleMutation) ResetRoleID() {
	m.role_id = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[role.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, role.FieldDeletedAt)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.role_id != nil {
		fields = append(fields, role.FieldRoleID)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	case role.FieldRoleID:
		return m.RoleID()
	case role.FieldDescription:
		return m.Description()
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldRoleID:
		return m.OldRoleID(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	if m.FieldCleared(role.FieldDeletedAt) {
		fields = append(fields, role.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	case role.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldRoleID:
		m.ResetRoleID()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	user_id                    *string
	username                   *string
	email                      *string
	password                   *[]byte
	first_name                 *string
	last_name                  *string
	is_admin_verified          *bool
	delete_protected           *bool
	api_key                    *string
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	clearedFields              map[string]struct{}
	google_oauth_tokens        *int
	clearedgoogle_oauth_tokens bool
	events                     map[int]struct{}
	removedevents              map[int]struct{}
	clearedevents              bool
	external_calendars         *int
	clearedexternal_calendars  bool
	roles                      map[int]struct{}
	removedroles               map[int]struct{}
	clearedroles               bool
	done                       bool
	oldValue                   func(context.Context) (*User, error)
	predicates                 []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserMutation) ResetUserID() {
	m.user_id = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetIsAdminVerified sets the "is_admin_verified" field.
func (m *UserMutation) SetIsAdminVerified(b bool) {
	m.is_admin_verified = &b
}

// IsAdminVerified returns the value of the "is_admin_verified" field in the mutation.
func (m *UserMutation) IsAdminVerified() (r bool, exists bool) {
	v := m.is_admin_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdminVerified returns the old "is_admin_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdminVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdminVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdminVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdminVerified: %w", err)
	}
	return oldValue.IsAdminVerified, nil
}

// ResetIsAdminVerified resets all changes to the "is_admin_verified" field.
func (m *UserMutation) ResetIsAdminVerified() {
	m.is_admin_verified = nil
}

// SetDeleteProtected sets the "delete_protected" field.
func (m *UserMutation) SetDeleteProtected(b bool) {
	m.delete_protected = &b
}

// DeleteProtected returns the value of the "delete_protected" field in the mutation.
func (m *UserMutation) DeleteProtected() (r bool, exists bool) {
	v := m.delete_protected
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteProtected returns the old "delete_protected" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeleteProtected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteProtected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteProtected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteProtected: %w", err)
	}
	return oldValue.DeleteProtected, nil
}

// ResetDeleteProtected resets all changes to the "delete_protected" field.
func (m *UserMutation) ResetDeleteProtected() {
	m.delete_protected = nil
}

// SetAPIKey sets the "api_key" field.
func (m *UserMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *UserMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ClearAPIKey clears the value of the "api_key" field.
func (m *UserMutation) ClearAPIKey() {
	m.api_key = nil
	m.clearedFields[user.FieldAPIKey] = struct{}{}
}

// APIKeyCleared returns if the "api_key" field was cleared in this mutation.
func (m *UserMutation) APIKeyCleared() bool {
	_, ok := m.clearedFields[user.FieldAPIKey]
	return ok
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *UserMutation) ResetAPIKey() {
	m.api_key = nil
	delete(m.clearedFields, user.FieldAPIKey)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetGoogleOauthTokensID sets the "google_oauth_tokens" edge to the GoogleOauthToken entity by id.
func (m *UserMutation) SetGoogleOauthTokensID(id int) {
	m.google_oauth_tokens = &id
}

// ClearGoogleOauthTokens clears the "google_oauth_tokens" edge to the GoogleOauthToken entity.
func (m *UserMutation) ClearGoogleOauthTokens() {
	m.clearedgoogle_oauth_tokens = true
}

// GoogleOauthTokensCleared reports if the "google_oauth_tokens" edge to the GoogleOauthToken entity was cleared.
func (m *UserMutation) GoogleOauthTokensCleared() bool {
	return m.clearedgoogle_oauth_tokens
}

// GoogleOauthTokensID returns the "google_oauth_tokens" edge ID in the mutation.
func (m *UserMutation) GoogleOauthTokensID() (id int, exists bool) {
	if m.google_oauth_tokens != nil {
		return *m.google_oauth_tokens, true
	}
	return
}

// GoogleOauthTokensIDs returns the "google_oauth_tokens" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GoogleOauthTokensID instead. It exists only for internal usage by the builders.
func (m *UserMutation) GoogleOauthTokensIDs() (ids []int) {
	if id := m.google_oauth_tokens; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGoogleOauthTokens resets all changes to the "google_oauth_tokens" edge.
func (m *UserMutation) ResetGoogleOauthTokens() {
	m.google_oauth_tokens = nil
	m.clearedgoogle_oauth_tokens = false
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *UserMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *UserMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *UserMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *UserMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *UserMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *UserMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *UserMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// SetExternalCalendarsID sets the "external_calendars" edge to the ExternalCalendar entity by id.
func (m *UserMutation) SetExternalCalendarsID(id int) {
	m.external_calendars = &id
}

// ClearExternalCalendars clears the "external_calendars" edge to the ExternalCalendar entity.
func (m *UserMutation) ClearExternalCalendars() {
	m.clearedexternal_calendars = true
}

// ExternalCalendarsCleared reports if the "external_calendars" edge to the ExternalCalendar entity was cleared.
func (m *UserMutation) ExternalCalendarsCleared() bool {
	return m.clearedexternal_calendars
}

// ExternalCalendarsID returns the "external_calendars" edge ID in the mutation.
func (m *UserMutation) ExternalCalendarsID() (id int, exists bool) {
	if m.external_calendars != nil {
		return *m.external_calendars, true
	}
	return
}

// ExternalCalendarsIDs returns the "external_calendars" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExternalCalendarsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ExternalCalendarsIDs() (ids []int) {
	if id := m.external_calendars; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExternalCalendars resets all changes to the "external_calendars" edge.
func (m *UserMutation) ResetExternalCalendars() {
	m.external_calendars = nil
	m.clearedexternal_calendars = false
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user_id != nil {
		fields = append(fields, user.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.is_admin_verified != nil {
		fields = append(fields, user.FieldIsAdminVerified)
	}
	if m.delete_protected != nil {
		fields = append(fields, user.FieldDeleteProtected)
	}
	if m.api_key != nil {
		fields = append(fields, user.FieldAPIKey)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUserID:
		return m.UserID()
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldIsAdminVerified:
		return m.IsAdminVerified()
	case user.FieldDeleteProtected:
		return m.DeleteProtected()
	case user.FieldAPIKey:
		return m.APIKey()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUserID:
		return m.OldUserID(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldIsAdminVerified:
		return m.OldIsAdminVerified(ctx)
	case user.FieldDeleteProtected:
		return m.OldDeleteProtected(ctx)
	case user.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldIsAdminVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdminVerified(v)
		return nil
	case user.FieldDeleteProtected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteProtected(v)
		return nil
	case user.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldAPIKey) {
		fields = append(fields, user.FieldAPIKey)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldAPIKey:
		m.ClearAPIKey()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUserID:
		m.ResetUserID()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldIsAdminVerified:
		m.ResetIsAdminVerified()
		return nil
	case user.FieldDeleteProtected:
		m.ResetDeleteProtected()
		return nil
	case user.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.google_oauth_tokens != nil {
		edges = append(edges, user.EdgeGoogleOauthTokens)
	}
	if m.events != nil {
		edges = append(edges, user.EdgeEvents)
	}
	if m.external_calendars != nil {
		edges = append(edges, user.EdgeExternalCalendars)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGoogleOauthTokens:
		if id := m.google_oauth_tokens; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeExternalCalendars:
		if id := m.external_calendars; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedevents != nil {
		edges = append(edges, user.EdgeEvents)
	}
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedgoogle_oauth_tokens {
		edges = append(edges, user.EdgeGoogleOauthTokens)
	}
	if m.clearedevents {
		edges = append(edges, user.EdgeEvents)
	}
	if m.clearedexternal_calendars {
		edges = append(edges, user.EdgeExternalCalendars)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeGoogleOauthTokens:
		return m.clearedgoogle_oauth_tokens
	case user.EdgeEvents:
		return m.clearedevents
	case user.EdgeExternalCalendars:
		return m.clearedexternal_calendars
	case user.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeGoogleOauthTokens:
		m.ClearGoogleOauthTokens()
		return nil
	case user.EdgeExternalCalendars:
		m.ClearExternalCalendars()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeGoogleOauthTokens:
		m.ResetGoogleOauthTokens()
		return nil
	case user.EdgeEvents:
		m.ResetEvents()
		return nil
	case user.EdgeExternalCalendars:
		m.ResetExternalCalendars()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VenueMutation represents an operation that mutates the Venue nodes in the graph.
type VenueMutation struct {
	config
	op            Op
	typ           string
	id            *int
	venue_id      *string
	name          *string
	description   *string
	web_site      *string
	postcode      *string
	prefecture    *string
	city          *string
	street        *string
	is_open       *bool
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	events        map[int]struct{}
	removedevents map[int]struct{}
	clearedevents bool
	done          bool
	oldValue      func(context.Context) (*Venue, error)
	predicates    []predicate.Venue
}

var _ ent.Mutation = (*VenueMutation)(nil)

// venueOption allows management of the mutation configuration using functional options.
type venueOption func(*VenueMutation)

// newVenueMutation creates new mutation for the Venue entity.
func newVenueMutation(c config, op Op, opts ...venueOption) *VenueMutation {
	m := &VenueMutation{
		config:        c,
		op:            op,
		typ:           TypeVenue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVenueID sets the ID field of the mutation.
func withVenueID(id int) venueOption {
	return func(m *VenueMutation) {
		var (
			err   error
			once  sync.Once
			value *Venue
		)
		m.oldValue = func(ctx context.Context) (*Venue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Venue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVenue sets the old Venue of the mutation.
func withVenue(node *Venue) venueOption {
	return func(m *VenueMutation) {
		m.oldValue = func(context.Context) (*Venue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VenueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VenueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VenueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VenueMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Venue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVenueID sets the "venue_id" field.
func (m *VenueMutation) SetVenueID(s string) {
	m.venue_id = &s
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *VenueMutation) VenueID() (r string, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldVenueID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *VenueMutation) ResetVenueID() {
	m.venue_id = nil
}

// SetName sets the "name" field.
func (m *VenueMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VenueMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VenueMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *VenueMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VenueMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VenueMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[venue.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VenueMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[venue.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VenueMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, venue.FieldDescription)
}

// SetWebSite sets the "web_site" field.
func (m *VenueMutation) SetWebSite(s string) {
	m.web_site = &s
}

// WebSite returns the value of the "web_site" field in the mutation.
func (m *VenueMutation) WebSite() (r string, exists bool) {
	v := m.web_site
	if v == nil {
		return
	}
	return *v, true
}

// OldWebSite returns the old "web_site" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldWebSite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebSite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebSite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebSite: %w", err)
	}
	return oldValue.WebSite, nil
}

// ClearWebSite clears the value of the "web_site" field.
func (m *VenueMutation) ClearWebSite() {
	m.web_site = nil
	m.clearedFields[venue.FieldWebSite] = struct{}{}
}

// WebSiteCleared returns if the "web_site" field was cleared in this mutation.
func (m *VenueMutation) WebSiteCleared() bool {
	_, ok := m.clearedFields[venue.FieldWebSite]
	return ok
}

// ResetWebSite resets all changes to the "web_site" field.
func (m *VenueMutation) ResetWebSite() {
	m.web_site = nil
	delete(m.clearedFields, venue.FieldWebSite)
}

// SetPostcode sets the "postcode" field.
func (m *VenueMutation) SetPostcode(s string) {
	m.postcode = &s
}

// Postcode returns the value of the "postcode" field in the mutation.
func (m *VenueMutation) Postcode() (r string, exists bool) {
	v := m.postcode
	if v == nil {
		return
	}
	return *v, true
}

// OldPostcode returns the old "postcode" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldPostcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostcode: %w", err)
	}
	return oldValue.Postcode, nil
}

// ClearPostcode clears the value of the "postcode" field.
func (m *VenueMutation) ClearPostcode() {
	m.postcode = nil
	m.clearedFields[venue.FieldPostcode] = struct{}{}
}

// PostcodeCleared returns if the "postcode" field was cleared in this mutation.
func (m *VenueMutation) PostcodeCleared() bool {
	_, ok := m.clearedFields[venue.FieldPostcode]
	return ok
}

// ResetPostcode resets all changes to the "postcode" field.
func (m *VenueMutation) ResetPostcode() {
	m.postcode = nil
	delete(m.clearedFields, venue.FieldPostcode)
}

// SetPrefecture sets the "prefecture" field.
func (m *VenueMutation) SetPrefecture(s string) {
	m.prefecture = &s
}

// Prefecture returns the value of the "prefecture" field in the mutation.
func (m *VenueMutation) Prefecture() (r string, exists bool) {
	v := m.prefecture
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefecture returns the old "prefecture" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldPrefecture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefecture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefecture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefecture: %w", err)
	}
	return oldValue.Prefecture, nil
}

// ClearPrefecture clears the value of the "prefecture" field.
func (m *VenueMutation) ClearPrefecture() {
	m.prefecture = nil
	m.clearedFields[venue.FieldPrefecture] = struct{}{}
}

// PrefectureCleared returns if the "prefecture" field was cleared in this mutation.
func (m *VenueMutation) PrefectureCleared() bool {
	_, ok := m.clearedFields[venue.FieldPrefecture]
	return ok
}

// ResetPrefecture resets all changes to the "prefecture" field.
func (m *VenueMutation) ResetPrefecture() {
	m.prefecture = nil
	delete(m.clearedFields, venue.FieldPrefecture)
}

// SetCity sets the "city" field.
func (m *VenueMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *VenueMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *VenueMutation) ClearCity() {
	m.city = nil
	m.clearedFields[venue.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *VenueMutation) CityCleared() bool {
	_, ok := m.clearedFields[venue.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *VenueMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, venue.FieldCity)
}

// SetStreet sets the "street" field.
func (m *VenueMutation) SetStreet(s string) {
	m.street = &s
}

// Street returns the value of the "street" field in the mutation.
func (m *VenueMutation) Street() (r string, exists bool) {
	v := m.street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "street" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldStreet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ClearStreet clears the value of the "street" field.
func (m *VenueMutation) ClearStreet() {
	m.street = nil
	m.clearedFields[venue.FieldStreet] = struct{}{}
}

// StreetCleared returns if the "street" field was cleared in this mutation.
func (m *VenueMutation) StreetCleared() bool {
	_, ok := m.clearedFields[venue.FieldStreet]
	return ok
}

// ResetStreet resets all changes to the "street" field.
func (m *VenueMutation) ResetStreet() {
	m.street = nil
	delete(m.clearedFields, venue.FieldStreet)
}

// SetIsOpen sets the "is_open" field.
func (m *VenueMutation) SetIsOpen(b bool) {
	m.is_open = &b
}

// IsOpen returns the value of the "is_open" field in the mutation.
func (m *VenueMutation) IsOpen() (r bool, exists bool) {
	v := m.is_open
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOpen returns the old "is_open" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldIsOpen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOpen: %w", err)
	}
	return oldValue.IsOpen, nil
}

// ResetIsOpen resets all changes to the "is_open" field.
func (m *VenueMutation) ResetIsOpen() {
	m.is_open = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VenueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VenueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VenueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VenueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VenueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VenueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VenueMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VenueMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Venue entity.
// If the Venue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VenueMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VenueMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[venue.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VenueMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[venue.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VenueMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, venue.FieldDeletedAt)
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *VenueMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *VenueMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *VenueMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *VenueMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *VenueMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *VenueMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *VenueMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the VenueMutation builder.
func (m *VenueMutation) Where(ps ...predicate.Venue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VenueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VenueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Venue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VenueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VenueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Venue).
func (m *VenueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VenueMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.venue_id != nil {
		fields = append(fields, venue.FieldVenueID)
	}
	if m.name != nil {
		fields = append(fields, venue.FieldName)
	}
	if m.description != nil {
		fields = append(fields, venue.FieldDescription)
	}
	if m.web_site != nil {
		fields = append(fields, venue.FieldWebSite)
	}
	if m.postcode != nil {
		fields = append(fields, venue.FieldPostcode)
	}
	if m.prefecture != nil {
		fields = append(fields, venue.FieldPrefecture)
	}
	if m.city != nil {
		fields = append(fields, venue.FieldCity)
	}
	if m.street != nil {
		fields = append(fields, venue.FieldStreet)
	}
	if m.is_open != nil {
		fields = append(fields, venue.FieldIsOpen)
	}
	if m.created_at != nil {
		fields = append(fields, venue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, venue.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, venue.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VenueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case venue.FieldVenueID:
		return m.VenueID()
	case venue.FieldName:
		return m.Name()
	case venue.FieldDescription:
		return m.Description()
	case venue.FieldWebSite:
		return m.WebSite()
	case venue.FieldPostcode:
		return m.Postcode()
	case venue.FieldPrefecture:
		return m.Prefecture()
	case venue.FieldCity:
		return m.City()
	case venue.FieldStreet:
		return m.Street()
	case venue.FieldIsOpen:
		return m.IsOpen()
	case venue.FieldCreatedAt:
		return m.CreatedAt()
	case venue.FieldUpdatedAt:
		return m.UpdatedAt()
	case venue.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VenueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case venue.FieldVenueID:
		return m.OldVenueID(ctx)
	case venue.FieldName:
		return m.OldName(ctx)
	case venue.FieldDescription:
		return m.OldDescription(ctx)
	case venue.FieldWebSite:
		return m.OldWebSite(ctx)
	case venue.FieldPostcode:
		return m.OldPostcode(ctx)
	case venue.FieldPrefecture:
		return m.OldPrefecture(ctx)
	case venue.FieldCity:
		return m.OldCity(ctx)
	case venue.FieldStreet:
		return m.OldStreet(ctx)
	case venue.FieldIsOpen:
		return m.OldIsOpen(ctx)
	case venue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case venue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case venue.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Venue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case venue.FieldVenueID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case venue.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case venue.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case venue.FieldWebSite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebSite(v)
		return nil
	case venue.FieldPostcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostcode(v)
		return nil
	case venue.FieldPrefecture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefecture(v)
		return nil
	case venue.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case venue.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case venue.FieldIsOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOpen(v)
		return nil
	case venue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case venue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case venue.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Venue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VenueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VenueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VenueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Venue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VenueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(venue.FieldDescription) {
		fields = append(fields, venue.FieldDescription)
	}
	if m.FieldCleared(venue.FieldWebSite) {
		fields = append(fields, venue.FieldWebSite)
	}
	if m.FieldCleared(venue.FieldPostcode) {
		fields = append(fields, venue.FieldPostcode)
	}
	if m.FieldCleared(venue.FieldPrefecture) {
		fields = append(fields, venue.FieldPrefecture)
	}
	if m.FieldCleared(venue.FieldCity) {
		fields = append(fields, venue.FieldCity)
	}
	if m.FieldCleared(venue.FieldStreet) {
		fields = append(fields, venue.FieldStreet)
	}
	if m.FieldCleared(venue.FieldDeletedAt) {
		fields = append(fields, venue.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VenueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VenueMutation) ClearField(name string) error {
	switch name {
	case venue.FieldDescription:
		m.ClearDescription()
		return nil
	case venue.FieldWebSite:
		m.ClearWebSite()
		return nil
	case venue.FieldPostcode:
		m.ClearPostcode()
		return nil
	case venue.FieldPrefecture:
		m.ClearPrefecture()
		return nil
	case venue.FieldCity:
		m.ClearCity()
		return nil
	case venue.FieldStreet:
		m.ClearStreet()
		return nil
	case venue.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Venue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VenueMutation) ResetField(name string) error {
	switch name {
	case venue.FieldVenueID:
		m.ResetVenueID()
		return nil
	case venue.FieldName:
		m.ResetName()
		return nil
	case venue.FieldDescription:
		m.ResetDescription()
		return nil
	case venue.FieldWebSite:
		m.ResetWebSite()
		return nil
	case venue.FieldPostcode:
		m.ResetPostcode()
		return nil
	case venue.FieldPrefecture:
		m.ResetPrefecture()
		return nil
	case venue.FieldCity:
		m.ResetCity()
		return nil
	case venue.FieldStreet:
		m.ResetStreet()
		return nil
	case venue.FieldIsOpen:
		m.ResetIsOpen()
		return nil
	case venue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case venue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case venue.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Venue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VenueMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, venue.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VenueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case venue.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VenueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, venue.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VenueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case venue.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VenueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, venue.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VenueMutation) EdgeCleared(name string) bool {
	switch name {
	case venue.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VenueMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Venue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VenueMutation) ResetEdge(name string) error {
	switch name {
	case venue.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Venue edge %s", name)
}
